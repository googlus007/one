Абстракция — отделение концепции от ее экземпляра; Полиморфизм — реализация задач одной и той же идеи разными способами; Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию; Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

System.Object

ToString Метод ToString служит для получения строкового представления данного объекта. Для базовых типов просто будет выводиться их строковое значение GetHashCode позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты. Можно определять самые разные алгоритмы генерации подобного числа или взять реализаци базового типа GetType позволяет получить тип данного объекта Equals позволяет сравнить два объекта на равенство:

class chel {

}

6.new, overide

Класс = срособ организации полей, методов и пр. Объект = экземпляр класса

Конструктор – это метод класса, предназначенный для инициализации объекта при его создании.

9.1) не имеет возвращаемого значения >2) имя такое же как и имя типа (класса)

Дестру?ктор — специальный метод класса, служащий для деинициализации объекта (например освобождения памяти).

this - Ключевое слово представляет ссылку на текущий экземпляр класса.

5 5; 7 7;

public, protected, private, internal

protected: такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках. internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).

Если мы будем использовать ref параметр то мы будем передавать ссылку, а не экземпляр переменной. Ключевое слово out используется для передачи аргументов по ссылке. Оно похоже на ключевое слово ref, за исключением того, что ref требует инициализации переменной перед ее передачей.

PrintOrderDetails(orderNum: 31, productName: "Red Mug", sellerName: "Gift Shop");

const int a = 15; readonly int b = 16; static int c = 228;

class Person { private int age;

public int Age { set { if (value < 18) { Console.WriteLine("Возраст должен быть больше 17"); } else { age = value; } } get { return age; } } }

value

Автоматическое свойство – это очень простое свойство, которое, в отличии от обычного свойства, уже определяет место в памяти (создает неявное поле), но при этом не позволяет создавать логику доступа. Структура объявления Автоматического свойства:

[модификатор доступа] [тип] [имя_свойства] { get; set; } У таких свойств, у их аксессоров отсутствует тело.

Индексаторы позволяют приложению обращаться с объектом класса так, как будто он является массивом. Индексатор во многом напоминает свойство, но в отличие от свойства он принимает в качестве параметра индекс массива. Так как объект класса используется как массив, то в качестве имени класса используется ключевое слово this. Определение индексатора синтаксически выглядит следующим образом

Перегрузка методов разрешает определение внутри одного класса двух или более методов с одним именем, если только объявления их параметров различны. В этом случае методы называют перегруженными, а процесс — перегрузкой методов.

В языке C# возможно разбиение определения класса, структуры или интерфейса между двумя или больше исходными файлами. Каждый исходный файл содержит свою часть определения класса и все такие части собираются во время компиляции. Есть несколько ситуаций, когда удачно разбить определение класса на несколько файлов: При работе над большим проектом, разбиение класса на несколько файлов позволяет нескольким программистам работать над ним
одновременно.

Анонимные типы позволяют создать объект с некоторым набором свойств без определения класса. Анонимный тип определяется с помощью ключевого слова var и инициализатора объектов:

25.Статический класс в основном такой же, как и нестатический класс, но имеется одно отличие: нельзя создавать экземпляры статического
класса. Другими словами, нельзя использовать ключевое слово new для создания переменной типа класса. Поскольку нет переменной
экземпляра, доступ к членам статического класса осуществляется с использованием самого имени класса.

26.Статический метод - вызывается на уровне типа (вызов: Имя_типа точка Имя_метода) Экземплярный метод - вызывается на уровне объявленного экземпляра типа (вызов: Имя_переменной точка Имя_метода).

Статические конструкторы или конструкторы типа . Конструктор экземпляра инициализирует данные экземпляра конструктор класса (типа)— данные класса. Свойства: >закрытые автоматически >не имеет параметров >нельзя вызвать явным образом (вызываются до создания первого экземпляра объекта или до вызова любого статического метода).

При поверхностном копировании копируются значения полей класса, включая значения любых указателей или ссылок. При этом скопированные значения этих указателей и ссылок указывают на одни и те же объекты, что и в оригинальном объекте, что зачастую ведет к ошибкам. Отсюда и название такого метода копирования: мы копируем только указатели/ссылки, вместо того, чтобы делать копии этих внутренних объектов и ссылаться на них, собственно не углубляемся во внутреннюю структуру объекта. При глубоком копировании мы копируем значени я полей не только на первом "уровне", но и заходим глубже, копируя все значения.

объекты равны если значения их полей равны, объекты тождественны если равны значения их ссылок.

Классы могут быть частичными. То есть мы можем иметь несколько файлов с определением одного и того же класса, и при компиляции все эти определения будут скомпилированы в одно. Частичные классы могут содержать частичные методы. Таким методы также опреляются с ключевым словом partial. Причем определение частичного метода без тела метода находится в одном частичном классе, а реализация этого же метода - в другом частичном классе.

System.Int32

a = 2; b = 1;

2

2

подходящий коеструктор не public

A static A

3